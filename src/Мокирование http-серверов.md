# Мокирование http-серверов

Для мокирования http-серверов в тестах необходимо использовать [Wiremock][wiremock].

Пример использования:
```java
@Test
void verifyRequestBody() {
    wireMockServer.stubFor(
        WireMock.post("/path/to/resource")
            .willReturn(WireMock.ok("responseBody")
                .withHeader("Content-Type", "application/json"))
    );

    var statusAndBody = httpClient.sendPostRequest("/path/to/resource", """
        {
            "need_to_check": "value",
            "no_need_to_check": "value"
        }
        """);

    assertEquals(200, statusAndBody.status());
    assertEquals("responseBody", statusAndBody.body());

    wireMockServer.verify(
        WireMock.postRequestedFor(WireMock.urlEqualTo("/path/to/resource"))
            .withRequestBody(WireMock.matchingJsonPath("$.need_to_check", WireMock.equalTo("value")))
    );
}
```


## Обоснование

В проекте СБП огромное количество независимых репозиториев, во многих из них есть http-клиенты, которые нужно тестировать.
Для тестирования http-клиентов в экосистеме java существует множество библиотек.
Если в каждом репозитории / модуле будет использоваться своя библиотека, 
то это существенно повысит порог входа для написания тестов как для недавно нанятых разработчиков, так и для "старичков".
Намного проще выучить API одной библиотеки и пользоваться знаниями от проекта к проекту.
Поэтому целесообразно выбрать одну библиотеку, которая наилучшим образом будет соответствовать нашим типичным сценариям тестирования.

При выборе реализации мока http-сервера было рассмотрено три реализации, которые уже использовались в тестах модулей СБП:
- [Wiremock][wiremock]
- [MockServer][mockserver]
- MockRestServiceServer

Рассматривать MockRestServiceServer далее нецелесообразно, так как он позволяет тестировать только http-клиенты, 
написанные с помощью RestTemplate, и при этом не развертывает настоящего http-сервера.
Из-за этого с его помощью невозможно протестировать, например, сценарий с таймаутом от http-сервера.
Поэтому в дальнейшем выборе сравнивались только Wiremock и MockServer.

Для сравнения реализаций рассматривались следующие сценарии тестирования:
- проверка вызова обычного GET эндпойнта (`/path/to/resource`);
- проверка вызова GET эндпойнта с параметризованным путем (`/resource/{id}`) и последующей проверкой значения;
- проверка вызова GET эндпойнта с query частью (`/path/to/resource?filter=value`) и последующей проверкой значения;
- проверка вызова POST эндпойнта с телом и последующей проверкой значений из тела запроса;
- проверка таймаутов;
- проверка ретраев.

Для рассмотрения примеров использования был подготовлен демо-проект https://github.com/Boiarshinov/java-testing-learning (см. модули `mockserver` и `wiremock`).

В результате сравнения было обнаружено:
- Wiremock активно поддерживается и регулярно получает обновления. MockServer обновляется крайне редко (~ раз в год);
- Значения времени старта Wiremock и MockServer имеют один порядок (~ 1 c);
- Выразительная способность API обеих библиотек позволяет протестировать все сценарии выше;
- Wiremock имеет более богатый API для проверки тел запросов;
- Сообщения об ошибках MockServer зачастую не дают подсказки о том, почему полученный запрос не соответствовал ожиданиям мока;
- Wiremock имеет более гибкий, но одновременно и более сложный API для описания сценариев, где один эндпойнт должен возвращать разные ответы (например, при тестировании ретраев).

В итоге Архитектурным сообществом СБП на [встрече от 25.10.2024 г.](https://confluence.nspk.ru/pages/viewpage.action?pageId=737586357) 
в качестве основного инструмента для тестирования http-клиентов был выбран Wiremock.


## Способ проверки

Проверка того, что для мокирования http-серверов в тестах используется Wiremock, проводится ревьювером.


[wiremock]: https://wiremock.org/docs/
[mockserver]: https://www.mock-server.com/
